模型
=======================

Spike-Zoo的模型组件 ``model`` 封装了网络架构 ``arch``，主要负责模型输入脉冲的预处理、输出图像的后处理以及训练相关的损失函数计算等功能。

参数配置
----------------
.. code-block:: python

    @dataclass
    class BaseModelConfig:
        # ------------- Not Recommended to Change -------------
        "Registerd model name."
        model_name: str = "base"
        "File name of the specified model."
        model_file_name: str = "nets"
        "Class name of the specified model in spikezoo/archs/base/{model_file_name}.py."
        model_cls_name: str = "BaseNet"
        "Spike input length. (local mode)"
        model_length: int = 41
        "Spike input length for different versions."
        model_length_dict: dict = field(default_factory=lambda: {"v010": 41, "v023": 41})
        "Model require model parameters or not."
        require_params: bool = True
        "Model parameters. (local mode)"
        model_params: dict = field(default_factory=lambda: {})
        "Model parameters for different versions."
        model_params_dict: dict = field(default_factory=lambda: {"v010": {}, "v023": {}})
        # ------------- Config -------------
        "Load ckpt path. Used on the local mode."
        ckpt_path: str = ""
        "Load pretrained weights or not. (default false, set to true during the evaluation mode.)"
        load_state: bool = False
        "Multi-GPU setting."
        multi_gpu: bool = False
        "Base url."
        base_url: str = "https://github.com/chenkang455/Spike-Zoo/releases/download"

参数说明如下：

- ``model_name`` : 注册的模型名称，如 ``"base"``, ``"spk2imgnet"`` 和 ``"spikeclip"``
- ``model_file_name`` : 模型架构定义文件名称，如 :file:`spikezoo/archs/base/nets.py`
- ``model_cls_name`` : 模型类名，对应 ``spikezoo/archs/base/nets.py`` 文件中的 ``BaseNet``
- ``model_length`` : 输入脉冲的标准长度，用于将输入裁剪为指定尺寸（本地模式）
- ``model_length_dict`` : 不同发行版本对应的输入脉冲长度
- ``require_params`` : 是否需要进行模型参数学习
- ``model_params`` : 模型初始化参数（本地模式），用于实例化 ``archs`` 中的网络
- ``model_params_dict`` : 不同发行版本对应的模型参数配置
- ``ckpt_path`` : 预训练权重加载路径（仅限本地模式使用）
- ``load_state`` : 是否加载预训练权重（默认关闭，评估模式需设为开启）
- ``multi_gpu`` : 是否启用多GPU训练模式
- ``base_url`` : 各版本预训练权重的云端存储地址

模型构建类
----------------

.. code-block:: python

    class BaseModel(nn.Module):
        # 初始化模型实例
        def __init__(self, cfg: BaseModelConfig):
        # 前向推理接口：输入脉冲，输出重建图像
        def forward(self, spike):
        # 核心转换方法：将单个脉冲转换为图像（被训练和推理接口调用）
        def spk2img(self, spike):
        # 网络构建方法：加载模型架构并选择是否加载权重
        def build_network(
            self,
            mode: Literal["debug", "train", "eval"] = "debug",
            version: Literal["local", "v010", "v023"] = "local",
        ):
        # 网络权重保存
        def save_network(self, save_path):
        # 输入脉冲长度裁剪
        def crop_spike_length(self, spike):
        # 输入脉冲预处理（尺寸调整、脉冲表征转换等）
        def preprocess_spike(self, spike):
        # 输出图像后处理（尺寸还原、亮度校正等）
        def postprocess_img(self, image):
        # 获取训练输出字典（训练时可能包含多组输出）
        def get_outputs_dict(self, batch):
        # 获取需要保存的可视化图像字典
        def get_visual_dict(self, batch, outputs):
        # 根据输出结果和输入数据计算损失值
        def get_loss_dict(self, outputs, batch, loss_weight_dict):
        # 损失函数定义方法
        def get_loss_func(self, name: Literal["l1", "l2"]):
        # 获取用于计算图像指标的真值-重建图像对
        def get_paired_imgs(self, batch, outputs):
        # 将输入数据载入计算设备
        def feed_to_device(self, batch):

**注意事项：**

- ``spk2img`` 实现单脉冲到重构图像的映射，但训练过程中涉及其他参数输入以及模型输出不单纯是重构图像，还包括一些辅助输出，故训练过程中利用 ``get_outputs_dict`` 函数来得到输出字典。

- ``forward`` 方法直接调用 ``spk2img`` 函数实现脉冲输入到重构图像的映射


.. _model_use:

实例化
----------------
模型除在 ``pipeline`` 中与 ``dataset`` 结合使用外，也可单独调用：

.. code-block:: python

    import spikezoo as sz
    from spikezoo.models.base_model import BaseModel, BaseModelConfig
    # 输入数据加载
    spike = sz.load_vidar_dat("data/data.dat", width=400, height=250, out_format="tensor")
    spike = spike[None].cuda()
    print(f"Input spike shape: {spike.shape}")
    # 网络初始化
    net = BaseModel(BaseModelConfig(model_params={"inDim": 41}))
    net.build_network(mode = "debug")
    # 推理过程
    recon_img = net(spike)
    print(recon_img.shape,recon_img.max(),recon_img.min())

``build_network`` 的典型用法：

.. code-block:: python

    # 1. 调试模式构建网络，是否加载权重由配置决定
    net.build_network(mode = "debug")
    # 2. 训练模式构建网络，是否加载权重由配置决定
    net.build_network(mode = "train")
    # 3. 评估模式构建网络，自动加载本地配置指定的预训练权重
    net.build_network(mode="eval", version="local")
    # 4. 评估模式构建网络，自动加载发行版预训练权重
    net.build_network(mode="eval", version="v023")

模式说明：

* ``debug`` : 调试模式，验证脉冲到图像的转换流程
* ``eval`` : 评估模式，支持从本地路径 ``ckpt_path`` 或发行版（如 ``v023``）加载权重
* ``train`` : 训练模式，默认不加载权重，可通过 ``load_state`` 参数控制权重加载


自定义模型开发
----------------
以下以 ``STIR`` 模型为例，说明自定义模型的封装流程：

1. 将STIR官方代码克隆至 ``spikezoo/archs/stir`` 目录

2. 定位模型定义文件 ``spikezoo/archs/stir/models/networks_STIR.py``，其中类名为 ``STIR``

3. 在 ``spikezoo/models`` 目录下创建 ``stir_model.py``，配置参数如下：

.. code-block:: python

    @dataclass
    class STIRConfig(BaseModelConfig):
        model_name: str = "stir"  # 需与文件名保持一致
        model_file_name: str = "models.networks_STIR"  # archs路径下的模块路径
        model_cls_name: str = "STIR"  # 模型类名
        model_length: int = 61  # 标准输入长度
        require_params: bool = True  # 需要参数初始化
        model_params: dict = field(default_factory=lambda: {})  # 使用默认参数

4. 继承基类实现STIR模型。由于涉及多次输入脉冲下采样处理，需重写脉冲预处理和后处理方法：

.. code-block:: python

    class STIR(BaseModel):
        def __init__(self, cfg: BaseModelConfig):
            super(STIR, self).__init__(cfg)

        def preprocess_spike(self, spike):
            spike = self.crop_spike_length(spike)
            if self.spike_size == (250, 400):
                spike = torch.cat([spike, spike[:, :, -6:]], dim=2)
            elif self.spike_size == (480, 854):
                spike = torch.cat([spike, spike[:, :, :, -10:]], dim=3)
            return spike

        def postprocess_img(self, image):
            if self.spike_size == (250, 400):
                image = image[:, :, :250, :]
            elif self.spike_size == (480, 854):
                image = image[:, :, :, :854]
            return image

        def get_outputs_dict(self, batch):
            spike = batch["spike"]
            rate = batch["rate"].view(-1, 1, 1, 1).float()
            outputs = {}
            spike = self.preprocess_spike(spike)
            img_pred_0, Fs_lv_0, Fs_lv_1, Fs_lv_2, Fs_lv_3, Fs_lv_4, Est = self.net(spike)
            img_pred_0 = self.postprocess_img(img_pred_0)
            outputs["recon_img"] = img_pred_0 / rate
            return outputs

5. STIR的多尺度金字塔损失函数可通过重写 ``get_loss_dict`` 实现，但因性能提升有限暂未实现